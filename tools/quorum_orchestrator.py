#!/usr/bin/env python3
"""
ECI Orchestrator — Ethical Continuous Integration for DVA
Pipeline:
  GPT(author) → DeepSeek(parse/lint) → Cursor(repo ops/tests) → ATLAS(audit)
  → GPT(quorum) → Attest to Ledger → (optional) Canary

This uses mocked agent calls you can swap with real APIs.
Quorum rule (default): require ≥3/4 model approvals + human dual-seal.
ATLAS integration: Quality & Integrity Gate with GI Score calculation.
"""

import os, sys, json, time, hashlib, subprocess, argparse
from pathlib import Path
import yaml
import requests

# Import ATLAS auditor
try:
    from atlas_auditor import AtlasAuditor
    ATLAS_AVAILABLE = True
except ImportError:
    ATLAS_AVAILABLE = False
    print("Warning: ATLAS auditor not available, falling back to basic audit")

# ---------- Config ----------
QUORUM_THRESHOLD = 3  # of 4 model votes
REQUIRED_HUMAN_SEALS = ["ANCHOR_SIGNER", "CUSTODIAN_SIGNER"]  # env var names
ARTIFACT_DIR = Path(os.getenv("ARTIFACT_DIR", "artifacts"))
ARTIFACT_DIR.mkdir(parents=True, exist_ok=True)

LEDGER_URL = os.getenv("LEDGER_URL", "https://civic-protocol-core-ledger.onrender.com/attest")
LEDGER_API_KEY = os.getenv("LEDGER_API_KEY", "")  # set in GitHub Secrets
DRY_RUN = os.getenv("DRY_RUN", "true").lower() == "true"

# ---------- Utilities ----------
def sha256_bytes(b: bytes) -> str:
    return hashlib.sha256(b).hexdigest()

def sha256_path(p: Path) -> str:
    return sha256_bytes(p.read_bytes())

def write_yaml(obj, path: Path):
    path.write_text(yaml.safe_dump(obj, sort_keys=False), encoding="utf-8")

def run(cmd, cwd=None, check=True):
    print(f"$ {' '.join(cmd)}")
    return subprocess.run(cmd, cwd=cwd, check=check, text=True, capture_output=True)

def require_env(keys):
    missing = [k for k in keys if not os.getenv(k)]
    if missing:
        raise SystemExit(f"Missing required env vars: {missing}")

# ---------- Mocked agent calls (swap with real SDKs/APIs) ----------
def gpt_author(prompt_path: Path) -> dict:
    """Mock: reads a source prompt and emits a code bundle path."""
    prompt = prompt_path.read_text(encoding="utf-8")
    bundle_dir = ARTIFACT_DIR / "bundle"
    bundle_dir.mkdir(exist_ok=True)
    # Example: create/update a tiny module as the "generated code"
    (bundle_dir / "module.py").write_text("# generated by GPT\nVALUE = 42\n", encoding="utf-8")
    report = {"agent":"gpt","ok":True,"artifact":str(bundle_dir),"prompt_hash":sha256_bytes(prompt.encode())}
    (ARTIFACT_DIR / "gpt_report.json").write_text(json.dumps(report,indent=2))
    return report

def deepseek_parse_lint(bundle_dir: Path) -> dict:
    """Mock: run a basic syntax check on .py files."""
    oks = []
    for p in bundle_dir.rglob("*.py"):
        try:
            run([sys.executable, "-m", "py_compile", str(p)])
            oks.append(str(p))
        except subprocess.CalledProcessError as e:
            return {"agent":"deepseek","ok":False,"error":e.stderr}
    rep = {"agent":"deepseek","ok":True,"checked":oks}
    (ARTIFACT_DIR / "deepseek_report.json").write_text(json.dumps(rep,indent=2))
    return rep

def cursor_scaffold_and_test(bundle_dir: Path, repo_dir: Path) -> dict:
    """Mock: copy bundle into a temp repo dir, init git, run tests if present."""
    repo_dir.mkdir(parents=True, exist_ok=True)
    # copy files
    for p in bundle_dir.rglob("*"):
        if p.is_file():
            dst = repo_dir / p.relative_to(bundle_dir)
            dst.parent.mkdir(parents=True, exist_ok=True)
            dst.write_bytes(p.read_bytes())
    # init git (mock)
    try:
        run(["git","init"], cwd=repo_dir)
        run(["git","add","-A"], cwd=repo_dir)
        run(["git","commit","-m","feat: add generated bundle"], cwd=repo_dir)
    except subprocess.CalledProcessError as e:
        return {"agent":"cursor","ok":False,"error":e.stderr}
    # run pytest if exists
    tests_ok = True
    coverage = 0
    if (repo_dir / "tests").exists():
        try:
            run([sys.executable, "-m", "pytest","-q"], cwd=repo_dir)
            tests_ok = True
            coverage = 80
        except subprocess.CalledProcessError as e:
            return {"agent":"cursor","ok":False,"error":e.stderr}
    rep = {"agent":"cursor","ok":tests_ok,"coverage":coverage,"repo":str(repo_dir)}
    (ARTIFACT_DIR / "cursor_report.json").write_text(json.dumps(rep,indent=2))
    return rep

def atlas_audit(repo_dir: Path) -> dict:
    """ATLAS Sentinel: Comprehensive quality & integrity audit with GI Score."""
    if not ATLAS_AVAILABLE:
        # Fallback to basic audit
        return claude_audit_fallback(repo_dir)
    
    try:
        # Get all files in repo for ATLAS audit
        files = [str(p) for p in repo_dir.rglob("*") if p.is_file()]
        
        # Initialize ATLAS auditor
        auditor = AtlasAuditor()
        
        # Run full ATLAS audit
        results = auditor.run_full_audit(files)
        
        # Save ATLAS attestation
        auditor.save_attestation(results, str(ARTIFACT_DIR / "atlas_attestation.json"))
        
        # Convert to legacy format for quorum
        rep = {
            "agent": "atlas",
            "ok": results["approved_for_quorum"],
            "gi_score": results["phases"]["gi_score"]["total"],
            "quality": results["phases"]["quality"],
            "drift": results["phases"]["drift"],
            "charter": results["phases"]["charter"],
            "attestation_hash": results["attestation"]["hash"],
            "cycle": results["cycle"]
        }
        
        (ARTIFACT_DIR / "atlas_report.json").write_text(json.dumps(rep, indent=2))
        return rep
        
    except Exception as e:
        print(f"ATLAS audit failed: {e}")
        return claude_audit_fallback(repo_dir)

def claude_audit_fallback(repo_dir: Path) -> dict:
    """Fallback: Basic audit when ATLAS is not available."""
    risky = []
    for p in repo_dir.rglob("*.py"):
        txt = p.read_text(encoding="utf-8")
        if "eval(" in txt or "subprocess.Popen(" in txt:
            risky.append(str(p))
    ok = len(risky) == 0
    rep = {"agent":"claude_fallback","ok":ok,"risky_files":risky}
    (ARTIFACT_DIR / "claude_report.json").write_text(json.dumps(rep,indent=2))
    return rep

def gpt_quorum(votes: list) -> dict:
    """Collect model votes and determine pass/fail."""
    approvals = sum(1 for v in votes if v.get("ok"))
    passed = approvals >= QUORUM_THRESHOLD
    rationale = f"{approvals}/4 models approved; threshold={QUORUM_THRESHOLD}"
    rep = {"agent":"gpt_quorum","ok":passed,"approvals":approvals,"rationale":rationale}
    (ARTIFACT_DIR / "quorum_report.json").write_text(json.dumps(rep,indent=2))
    return rep

# ---------- Attestation ----------
def attest_to_ledger(payload: dict) -> dict:
    headers = {"Content-Type":"application/json"}
    if LEDGER_API_KEY:
        headers["Authorization"] = f"Bearer {LEDGER_API_KEY}"
    print("Attesting to Ledger:", LEDGER_URL)
    if DRY_RUN:
        (ARTIFACT_DIR / "ledger_attestation.json").write_text(json.dumps(payload,indent=2))
        return {"ok":True,"dry_run":True}
    r = requests.post(LEDGER_URL, headers=headers, json=payload, timeout=20)
    ok = r.status_code in (200,201,202)
    return {"ok":ok,"status":r.status_code,"body":r.text}

# ---------- Main ----------
def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--prompt", default="PROMPT.md", help="Path to authoring prompt")
    ap.add_argument("--workdir", default="workrepo", help="Temp repo dir")
    ap.add_argument("--title", default="Automated change via ECI")
    args = ap.parse_args()

    prompt_path = Path(args.prompt)
    repo_dir = Path(args.workdir)

    # 1) Author
    gpt = gpt_author(prompt_path)
    bundle = Path(gpt["artifact"])

    # 2) Parse/Lint
    deepseek = deepseek_parse_lint(bundle)

    # 3) Repo + tests
    cursor = cursor_scaffold_and_test(bundle, repo_dir)

    # 4) ATLAS Audit
    atlas = atlas_audit(repo_dir)

    # 5) Quorum
    quorum = gpt_quorum([gpt, deepseek, cursor, atlas])

    # 6) Human dual-seal check (environment-protected approval step)
    seals = {}
    for key in REQUIRED_HUMAN_SEALS:
        seals[key] = bool(os.getenv(key))
    humans_ok = all(seals.values())

    status = "proposed"
    if quorum["ok"] and humans_ok:
        status = "approved"
    elif not quorum["ok"]:
        status = "rejected_model_quorum"
    else:
        status = "waiting_human_seals"

    # 7) Change proposal artifact
    proposal = {
        "id": hashlib.sha1(str(time.time()).encode()).hexdigest()[:12],
        "title": args.title,
        "models_used": [
            {"name":"gpt","report":"gpt_report.json"},
            {"name":"deepseek","report":"deepseek_report.json"},
            {"name":"cursor","report":"cursor_report.json"},
            {"name":"atlas","report":"atlas_report.json"},
            {"name":"gpt_quorum","report":"quorum_report.json"},
        ],
        "repo": {"path": str(repo_dir)},
        "attestations": {
            "model_quorum_ok": quorum["ok"],
            "human_seals": seals,
        },
        "status": status,
        "timestamp": int(time.time())
    }
    write_yaml(proposal, ARTIFACT_DIR / "change_proposal.yaml")

    # 8) Ledger attestation (always append-only, even for rejects)
    att_payload = {
        "namespace": "dva.upgrade",
        "action": "proposal",
        "status": status,
        "proposal": proposal,
        "hash": sha256_path(ARTIFACT_DIR / "change_proposal.yaml"),
    }
    res = attest_to_ledger(att_payload)
    print("Ledger response:", res)

    # Exit non-zero if not approved (so CI can block deployment)
    if status != "approved":
        print(f"ECI pipeline completed with status={status}")
        sys.exit(1)

    print("ECI pipeline APPROVED — ready for canary/rollout.")
    return 0

if __name__ == "__main__":
    sys.exit(main())