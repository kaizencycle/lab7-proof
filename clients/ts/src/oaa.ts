// Autogenerated from openapi.yaml (handcrafted for v0.1.0 MVP)
// Minimal types + fetch helpers for /v1/session/*

export type MentorName = "gemini" | "claude" | "deepseek" | "perplexity";

export interface StartSessionRequest {
  user_id: string;
  mentors?: MentorName[];
}
export interface StartSessionResponse {
  session_id: string;
  mentors: MentorName[];
  started_at: string; // ISO
}
export interface TurnRequest {
  session_id: string;
  prompt: string;
  tools?: MentorName[];
}
export interface TurnResponse {
  session_id: string;
  drafts: Record<string, string>;
  meta?: Record<string, unknown>;
}
export interface SubmitRequest {
  session_id: string;
  user_id: string;
  prompt: string;
  answer: string;
}
export interface RubricScores {
  accuracy: number; depth: number; originality: number; integrity: number;
}
export interface SubmitResponse {
  attestation_id: string;
  xp_awarded: number;
  level_before: number;
  level_after: number;
  reward_tx_id?: string | null;
  balance_after?: number | null;
}
export interface CritiqueRequest {
  session_id: string;
  prompt: string;
  answer: string;
}
export interface CritiqueResponse {
  rubric: RubricScores;
  critique: string;
}
export interface ApiError { code: string; message: string; details?: unknown }

export type FetchLike = (input: RequestInfo, init?: RequestInit) => Promise<Response>;

export class OAAClient {
  constructor(
    private baseUrl: string = "http://localhost:8080",
    private fetchImpl: FetchLike = (input, init) => fetch(input, init),
    private defaultHeaders: Record<string, string> = {}
  ) {}

  private url(path: string) { return `${this.baseUrl}${path}`; }
  private async req<T>(path: string, body?: unknown, init?: RequestInit): Promise<T> {
    const res = await this.fetchImpl(this.url(path), {
      method: "POST",
      headers: { "content-type": "application/json", ...this.defaultHeaders, ...(init?.headers || {}) },
      body: body ? JSON.stringify(body) : undefined,
      ...init,
    });
    if (!res.ok) {
      let err: any;
      try { err = await res.json(); } catch { err = { message: await res.text() }; }
      const apiErr: ApiError = { code: err.code ?? String(res.status), message: err.message ?? "Request failed", details: err.details };
      throw apiErr;
    }
    return res.json() as Promise<T>;
  }

  startSession(body: StartSessionRequest) {
    return this.req<StartSessionResponse>("/v1/session/start", body);
  }
  turn(body: TurnRequest) {
    return this.req<TurnResponse>("/v1/session/turn", body);
  }
  submit(body: SubmitRequest) {
    return this.req<SubmitResponse>("/v1/session/submit", body);
  }
  critique(body: CritiqueRequest) {
    return this.req<CritiqueResponse>("/v1/session/critique", body);
  }
}
